const n=Object.assign,t=t=>(...o)=>n(document.createElement(t),...o),o=t("canvas"),c=(n,t,o)=>(...c)=>(o(t),c.forEach((o=>o(n,t))),o(null),t),e=(n,t,o)=>n.getUniformLocation(t,o),a=(n,t=34962)=>{const o=n.createBuffer();return c(n,o,(o=>n.bindBuffer(t,o)))},s=(n,t=3553)=>{const o=n.createTexture();return c(n,o,(o=>n.bindTexture(t,o)))},r=(n,t,o)=>{const c="#version 300 es\n"+o,e=n.createShader(t);if(n.shaderSource(e,c),n.compileShader(e),!n.getShaderParameter(e,35713)){const t=n.getShaderInfoLog(e);throw Error(`Shader error:\n${t}\n${((n,t=1)=>n.replace(/^/gm,(()=>(t+++": ").padStart(5,"0"))))(c)}\n`)}return e},v=(n,t,o)=>{const c=n.createProgram();if(n.attachShader(c,r(n,35633,t)),n.attachShader(c,r(n,35632,o)),n.linkProgram(c),!n.getProgramParameter(c,35714)){const t=n.getProgramInfoLog(c);throw Error("Program error: "+t)}return c},i=t("video")({src:"videos/Reach for the Dead.mp4",controls:!0,autoplay:!0,loop:!0});window.addEventListener("dragover",(n=>{n.preventDefault()})),window.addEventListener("drop",(n=>{n.preventDefault();const[t]=n.dataTransfer.files;if(t){const n=URL.createObjectURL(t);i.src=n}}));const _=((n,...t)=>{const c=o().getContext("webgl2",n);if(!c)throw Error("WebGL2 is unavailable");for(const n of t)if(!c.getExtension(n))throw Error(`"${n}" extension is unavailable`);return c})({},"EXT_color_buffer_float","EXT_float_blend");document.body.append(i,_.canvas);const l="\n#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n\nconst vec3 D65 = xy_to_XYZ(0.31271, 0.32902);\nconst mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));\nconst mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);\nconst mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);\n\nvec3 sRGB_OETF(vec3 c) {\n  vec3 a = 12.92*c;\n  vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n  return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n  vec3 a = c/12.92;\n  vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n  return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}\n\n#define adapt_aux(x) pow(F_L*abs(x), vec3(0.42))\n#define adapt(x) 400.0*sign(x)*adapt_aux(x)/(27.13 + adapt_aux(x))\n#define unadapt(x) sign(x)/F_L*pow(27.13*abs(x)/(400.0 - abs(x)), vec3(1.0/0.42))\n\nconst mat3 M16 = mat3(\n  +0.401288, -0.250268, -0.002079,\n  +0.650173, +1.204414, +0.048952,\n  -0.051461, +0.045854, +0.953127\n);\n\n// sRGB conditions, average surround\nconst vec3 XYZ_w = D65;\nconst float Y_w = XYZ_w.y;\nconst float Y_b = 0.2;\nconst float L_w = 64.0/radians(180.0);\nconst float L_A = L_w*Y_b/Y_w;\nconst float F = 1.0;\nconst float c = 0.69;\nconst float N_c = F;\n\nconst vec3 RGB_w = M16*XYZ_w;\nconst float D = 1.0; // clamp(F*(1.0 - 1.0/3.6*exp((-L_A - 42.0)/92.0)), 0.0, 1.0);\nconst vec3 D_RGB = D*(Y_w/RGB_w) + 1.0 - D;\nconst float k4 = pow(1.0/(5.0*L_A + 1.0), 4.0);\nconst float F_L = k4*L_A + 0.1*pow(1.0 - k4, 2.0)*pow(5.0*L_A, 1.0/3.0);\nconst float n = Y_b/Y_w;\nconst float z = 1.48 + sqrt(n);\nconst float N_bb = 0.725/pow(n, 0.2);\nconst float N_cb = N_bb;\nconst vec3 RGB_cw = D_RGB*RGB_w;\nconst vec3 RGB_aw = adapt(RGB_cw);\nconst float A_w = dot(vec3(2.0, 1.0, 0.05), RGB_aw)*N_bb;\n\nvec3 XYZ_D65_to_CAM16(vec3 XYZ) {\n  vec3 RGB = M16*XYZ;\n  vec3 RGB_c = D_RGB*RGB;\n  vec3 RGB_a = adapt(RGB_c);\n  const mat3x4 m = 1.0/1980.0*mat3x4(\n    3960.0, 1980.0, 220.0, 1980.0,\n    1980.0, -2160.0, 220.0, 1980.0,\n    99.0, 180.0, -440.0, 2079.0\n  );\n  vec4 aux = m*RGB_a;\n  float h = atan(aux.z, aux.y);\n  float e_t = 0.25*(cos(h + 2.0) + 3.8);\n  float A = aux.x*N_bb;\n  float J = pow(A/A_w, c*z);\n  float t = 5e4/13.0*N_c*N_cb*e_t*length(aux.yz)/(aux.w + 0.305);\n  float alpha = pow(t, 0.9)*pow(1.64 - pow(0.29, n), 0.73);\n  float C = 0.01*alpha*sqrt(J);\n  float M = C*pow(F_L, 0.25);\n  return vec3(J, M, h);\n}\n\nvec3 CAM16_to_XYZ_D65(vec3 JMh) {\n  float C = JMh.y/pow(F_L, 0.25);\n  float alpha = 100.0*C/sqrt(JMh.x);\n  float t = pow(alpha/pow(1.64 - pow(0.29, n), 0.73), 1.0/0.9);\n  float e_t = 0.25*(cos(JMh.z + 2.0) + 3.8);\n  float A = A_w*pow(JMh.x, 1.0/(c*z));\n  float p_1 = 5e4/13.0*N_c*N_cb*e_t;\n  float p_2 = A/N_bb;\n  vec2 cs = vec2(cos(JMh.z), sin(JMh.z));\n  float r = 23.0*(p_2 + 0.305)*t/(23.0*p_1 + t*dot(vec2(11.0, 108.0), cs));\n  vec2 ab = r*cs;\n  const mat3 m = 1.0/1403.0*mat3(\n    460.0, 460.0, 460.0,\n    451.0, -891.0, -220.0,\n    288.0, -261.0, -6300.0\n  );\n  vec3 RGB_a = m*vec3(p_2, ab);\n  vec3 RGB_c = unadapt(RGB_a);\n  vec3 RGB = RGB_c/D_RGB;\n  return inverse(M16)*RGB;\n}\n\nvec3 XYZ_D65_to_CAM16_UCS(vec3 XYZ) {\n  vec3 JMh = XYZ_D65_to_CAM16(XYZ);\n  float J = (1.0 + 0.7)*JMh.x/(1.0 + 0.7*JMh.x);\n  float M = 1.0/2.28*log(1.0 + 2.28*JMh.y);\n  return vec3(J, M, JMh.z);\n}\n\nvec3 CAM16_UCS_to_XYZ_D65(vec3 JMh) {\n  float J = JMh.x/(1.0 - (JMh.x - 1.0)*0.7);\n  float M = (exp(JMh.y*2.28) - 1.0)/2.28;\n  return CAM16_to_XYZ_D65(vec3(J, M, JMh.z));\n}\n",f=v(_,`\nuniform sampler2D uSrc;\nuniform float uTime;\nlayout(location=1) in int aPosition;\nout vec3 vColor;\n\n${l}\n\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3*vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash43(vec3 p) {\n  vec4 p4 = fract(vec4(p.xyzx)*vec4(.1031, .1030, .0973, .1099));\n  p4 += dot(p4, p4.wzxy + 33.33);\n  return fract((p4.xxyz + p4.yzzw)*p4.zywx);\n}\n\nmat2 rot(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nvec3 sphere(vec2 uv) {\n  float theta = radians(360.0)*uv.x;\n  float phi = acos(1.0 - 2.0*uv.y);\n  float x = sin(phi)*cos(theta);\n  float y = sin(phi)*sin(theta);\n  float z = cos(phi);\n  return vec3(x, y, z);\n}\n\nvec3 radiate(vec3 p) {\n  vec4 h = hash43(1e3*p);\n  return sphere(h.xy)/(1e3*h.z + h.w);\n}\n\nmat4 persp(float fov, float ar, float n, float f) {\n  float thf = tan(fov/2.0);\n  return mat4(\n    1.0/(ar*thf), 0.0, 0.0, 0.0,\n    0.0, 1.0/(thf), 0.0, 0.0,\n    0.0, 0.0, -(f + n)/(f - n), -1.0,\n    0.0, 0.0, -(2.0*f*n)/(f - n), 0.0\n  );\n}\n\nvoid main() {\n  ivec2 ts = textureSize(uSrc, 0);\n  ivec2 xy = ivec2(aPosition%ts.x, aPosition/ts.y);\n  vec2 uv = (0.5 + vec2(xy))/vec2(ts);\n  vec4 t = texture(uSrc, uv);\n  // vec3 sRGB = hash33(1e4*vec3(fract(uTime), uv));\n  vec3 sRGB = sRGB_EOTF(t.rgb);\n  vec3 JMh = XYZ_D65_to_CAM16_UCS(sRGB_TO_XYZ_D65*sRGB);\n  vec3 Jab = vec3(JMh.x, JMh.y*vec2(cos(JMh.z), sin(JMh.z)));\n  // vec4 p = vec4(t.rgb - 0.5, 1.0);\n  vec4 p = vec4(Jab.yxz, 1.0);\n  p.y -= 0.5;\n  p.xz *= rot(radians(30.0)*uTime);\n  p.xyz += radiate(vec3(fract(uTime), uv));\n  p.z -= 2.0;\n  p = persp(radians(35.0), 1.0, 1e-3, 1e1)*p;\n  float s = 1.0/p.w;\n  float cs = ceil(s);\n  vColor = (s*s)/(cs*cs)*sRGB;\n  gl_Position = p;\n  gl_PointSize = cs;\n}\n`,"\nprecision highp float;\nin vec3 vColor;\nout vec4 fColor;\n\nvoid main() {\n  fColor = vec4(vColor, 1.0);\n}\n"),p=v(_,"\nlayout(location=0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n  vPosition = 0.5 + 0.5*aPosition;\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n",`\nprecision highp float;\nuniform sampler2D sSrc;\nin vec2 vPosition;\nout vec4 fColor;\n\n${l}\n\nvec3 ACES(vec3 color) {\n  const mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n  const mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n  vec3 v = x*color;\n  vec3 a = v*(v + 0.0245786) - 0.000090537;\n  vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n  return clamp(y*(a/b), 0.0, 1.0);\n}\n\n\nfloat gauss(float sigma, vec2 xy) {\n  const float pi = radians(180.0);\n  float k = 2.0*pow(sigma, 2.0);\n  return exp(-dot(xy, xy)/k)/(pi*k);\n}\n\nvoid main() {\n  vec2 s = 1.0/vec2(textureSize(sSrc, 0));\n  vec3 c = texture(sSrc, vPosition).rgb;\n  for (float y = -6.0; y <= 6.0; y += 1.0) {\n    for (float x = -6.0; x <= 6.0; x += 1.0) {\n      vec2 xy = vec2(x, y);\n      c += gauss(2.0, xy)*texture(sSrc, vPosition + s*xy).rgb;\n    }\n  }\n  fColor = vec4(sRGB_OETF(ACES(0.2*c)), 1.0);\n}\n`),x=s(_)((n=>{n.texParameteri(3553,10241,9729),n.texParameteri(3553,10240,9729)}),(n=>{n.pixelStorei(37440,!0)})),u=s(_)((n=>{n.texParameteri(3553,10241,9728),n.texParameteri(3553,10240,9728)})),h=((n,t=36160)=>{const o=n.createFramebuffer();return c(n,o,(o=>n.bindFramebuffer(t,o)))})(_)();a(_)((n=>{const t=new Int32Array(Array(2073600).keys());n.bufferData(34962,t,35044),n.vertexAttribIPointer(1,1,5124,0,0),n.enableVertexAttribArray(1)})),a(_)((n=>{const t=Float32Array.of(-1,1,-1,-3,3,1);n.bufferData(34962,t,35044),n.vertexAttribPointer(0,2,5126,!1,0,0),n.enableVertexAttribArray(0)})),_.enable(3042),_.blendFunc(1,1),_.clearColor(0,0,0,1),_.clear(16384);(async()=>{const t=600,o=600;for(n(_.canvas,{width:t,height:o});;){const n=await new Promise(requestAnimationFrame),{videoWidth:c,videoHeight:a}=i;c&&(_.activeTexture(33984),_.bindTexture(3553,x),_.texImage2D(3553,0,6408,6408,5121,i),_.activeTexture(33985),_.bindTexture(3553,u),_.texImage2D(3553,0,34836,t,o,0,6408,5126,null),_.useProgram(f),_.uniform1f(e(_,f,"uTime"),.001*n),_.bindFramebuffer(36160,h),_.framebufferTexture2D(36160,36064,3553,u,0),_.viewport(0,0,t,o),_.clear(16384),_.drawArrays(0,0,c*a),_.bindFramebuffer(36160,null),_.activeTexture(33984),_.bindTexture(3553,u),_.useProgram(p),_.viewport(0,0,t,o),_.clear(16384),_.drawArrays(4,0,3))}})();

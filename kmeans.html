<!DOCTYPE html>
<style>
  body { min-height: 100vh; margin: 0; background: #111; display: flex; }
  body { align-items: center; justify-content: center; flex-direction: column; }
  video { width: 560px; outline: none; }
</style>
<script type='module'>
var n,o,e,t,a,i;const c=Object.assign,s=n=>(...o)=>c(document.createElement(n),...o),v=s("canvas"),r=(n,o,e)=>(...t)=>(e(o),t.forEach((e=>e(n,o))),e(null),o),l=(n,o)=>e=>n.getUniformLocation(o,e),u=(n,o=34962)=>{const e=n.createBuffer();return r(n,e,(e=>n.bindBuffer(o,e)))},p=(n,o=3553)=>{const e=n.createTexture();return r(n,e,(e=>n.bindTexture(o,e)))},_=(n,o,e)=>{const t="#version 300 es\n"+e,a=n.createShader(o);if(n.shaderSource(a,t),n.compileShader(a),!n.getShaderParameter(a,35713)){const o=n.getShaderInfoLog(a);throw Error(`Shader error:\n${o}\n${((n,o=1)=>n.replace(/^/gm,(()=>(o+++": ").padStart(5,"0"))))(t)}\n`)}return a},f=(n,o,e)=>{const t=n.createProgram();if(n.attachShader(t,_(n,35633,o)),n.attachShader(t,_(n,35632,e)),n.linkProgram(t),!n.getProgramParameter(t,35714)){const o=n.getProgramInfoLog(t);throw Error("Program error: "+o)}n.useProgram(t);for(let o,e=0;o=n.getUniformLocation(t,"uSampler"+e);)n.uniform1i(o,e++);return n.useProgram(null),t},m=(n,o)=>`\n#ifndef LIB_${n}\n#define LIB_${n}\n${o}\n#endif // LIB_${n}\n`,x=((n,...o)=>{const e=v().getContext("webgl2",n);if(!e)throw Error("WebGL2 is unavailable");for(const n of o)if(!e.getExtension(n))throw Error(`"${n}" extension is unavailable`);return e})({},"EXT_color_buffer_float","EXT_float_blend");(n=>{n.video=s("video")({src:location.search.slice(1)||"videos/MAGIC_FLUIDS.webm",crossOrigin:"anonymous",controls:!0,autoplay:!0,loop:!0}),document.body.append(n.video,x.canvas),window.addEventListener("dragover",(n=>{n.preventDefault()})),window.addEventListener("drop",(o=>{o.preventDefault();const[e]=o.dataTransfer.files;if(e){const o=URL.createObjectURL(e);n.video.src=o}}))})(n||(n={})),(n=>{n.sRGB=m("SRGB","\n    #define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n    #define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n\n    const vec3 D65 = xy_to_XYZ(0.31271, 0.32902);\n    const mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));\n    const mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);\n    const mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);\n\n    vec3 sRGB_OETF(vec3 c) {\n      vec3 a = 12.92*c;\n      vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n      return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n    }\n\n    vec3 sRGB_EOTF(vec3 c) {\n      vec3 a = c/12.92;\n      vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n      return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n    }\n  "),n.CAM16=m("CAM16",`\n    ${n.sRGB}\n\n    #define adapt_aux(x) pow(F_L*abs(x), vec3(0.42))\n    #define adapt(x) 400.0*sign(x)*adapt_aux(x)/(27.13 + adapt_aux(x))\n    #define unadapt(x) sign(x)/F_L*pow(27.13*abs(x)/(400.0 - abs(x)), vec3(1.0/0.42))\n\n    const mat3 M16 = mat3(\n      +0.401288, -0.250268, -0.002079,\n      +0.650173, +1.204414, +0.048952,\n      -0.051461, +0.045854, +0.953127\n    );\n\n    // sRGB conditions, average surround\n    const vec3 XYZ_w = D65;\n    const float Y_w = XYZ_w.y;\n    const float Y_b = 0.2;\n    const float L_w = 64.0/radians(180.0);\n    const float L_A = L_w*Y_b/Y_w;\n    const float F = 1.0;\n    const float c = 0.69;\n    const float N_c = F;\n\n    const vec3 RGB_w = M16*XYZ_w;\n    const float D = 1.0; // clamp(F*(1.0 - 1.0/3.6*exp((-L_A - 42.0)/92.0)), 0.0, 1.0);\n    const vec3 D_RGB = D*(Y_w/RGB_w) + 1.0 - D;\n    const float k4 = pow(1.0/(5.0*L_A + 1.0), 4.0);\n    const float F_L = k4*L_A + 0.1*pow(1.0 - k4, 2.0)*pow(5.0*L_A, 1.0/3.0);\n    const float n = Y_b/Y_w;\n    const float z = 1.48 + sqrt(n);\n    const float N_bb = 0.725/pow(n, 0.2);\n    const float N_cb = N_bb;\n    const vec3 RGB_cw = D_RGB*RGB_w;\n    const vec3 RGB_aw = adapt(RGB_cw);\n    const float A_w = dot(vec3(2.0, 1.0, 0.05), RGB_aw)*N_bb;\n\n    vec3 sRGB_to_CAM16(vec3 sRGB) {\n      vec3 RGB = M16*sRGB_TO_XYZ_D65*sRGB;\n      vec3 RGB_c = D_RGB*RGB;\n      vec3 RGB_a = adapt(RGB_c);\n      const mat3x4 m = 1.0/1980.0*mat3x4(\n        3960.0, 1980.0, 220.0, 1980.0,\n        1980.0, -2160.0, 220.0, 1980.0,\n        99.0, 180.0, -440.0, 2079.0\n      );\n      vec4 aux = m*RGB_a;\n      float h = atan(aux.z, aux.y);\n      float e_t = 0.25*(cos(h + 2.0) + 3.8);\n      float A = aux.x*N_bb;\n      float J = pow(A/A_w, c*z);\n      float t = 5e4/13.0*N_c*N_cb*e_t*length(aux.yz)/(aux.w + 0.305);\n      float alpha = pow(t, 0.9)*pow(1.64 - pow(0.29, n), 0.73);\n      float C = 0.01*alpha*sqrt(J);\n      float M = C*pow(F_L, 0.25);\n      return vec3(J, M, h);\n    }\n\n    vec3 CAM16_to_sRGB(vec3 JMh) {\n      float C = JMh.y/pow(F_L, 0.25);\n      float alpha = JMh.x == 0.0 ? 0.0 : 100.0*C/sqrt(JMh.x);\n      float t = pow(alpha/pow(1.64 - pow(0.29, n), 0.73), 1.0/0.9);\n      float e_t = 0.25*(cos(JMh.z + 2.0) + 3.8);\n      float A = A_w*pow(JMh.x, 1.0/(c*z));\n      float p_1 = 5e4/13.0*N_c*N_cb*e_t;\n      float p_2 = A/N_bb;\n      vec2 cs = vec2(cos(JMh.z), sin(JMh.z));\n      float r = 23.0*(p_2 + 0.305)*t/(23.0*p_1 + t*dot(vec2(11.0, 108.0), cs));\n      vec2 ab = r*cs;\n      const mat3 m = 1.0/1403.0*mat3(\n        460.0, 460.0, 460.0,\n        451.0, -891.0, -220.0,\n        288.0, -261.0, -6300.0\n      );\n      vec3 RGB_a = m*vec3(p_2, ab);\n      vec3 RGB_c = unadapt(RGB_a);\n      vec3 RGB = RGB_c/D_RGB;\n      return XYZ_D65_TO_sRGB*inverse(M16)*RGB;\n    }\n\n    vec3 sRGB_to_CAM16_UCS(vec3 sRGB) {\n      vec3 JMh = sRGB_to_CAM16(sRGB);\n      float J = (1.0 + 0.7)*JMh.x/(1.0 + 0.7*JMh.x);\n      float M = 1.0/2.28*log(1.0 + 2.28*JMh.y);\n      return vec3(J, M*vec2(cos(JMh.z), sin(JMh.z)));\n    }\n\n    vec3 CAM16_UCS_to_sRGB(vec3 Jab) {\n      vec3 JMh = vec3(Jab.x, length(Jab.yz), atan(Jab.z, Jab.y));\n      float J = JMh.x/(1.0 - (JMh.x - 1.0)*0.7);\n      float M = (exp(JMh.y*2.28) - 1.0)/2.28;\n      return CAM16_to_sRGB(vec3(J, M, JMh.z));\n    }\n  `),n.ACES=m("ACES","\n    vec3 ACES(vec3 color) {\n      const mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n      const mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n      vec3 v = x*color;\n      vec3 a = v*(v + 0.0245786) - 0.000090537;\n      vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n      return clamp(y*(a/b), 0.0, 1.0);\n    }\n  "),n.kMeans=m("KMEANS","\n    #define K 25\n\n    uniform vec3 uMeans[K];\n\n    int closest(vec3 point) {\n      struct Pair { int i; float d; };\n      Pair min = Pair(0, 1e10);\n      for (int i = 0; i < K; i++) {\n        vec3 v = uMeans[i] - point;\n        float d = dot(v, v);\n        if (d < min.d) min = Pair(i, d);\n      }\n      return min.i;\n    }\n  ")})(o||(o={})),(n=>{n.convert=f(x,"\n    layout(location=0) in vec2 aPosition;\n    out vec2 vPosition;\n\n    void main() {\n      vPosition = 0.5 + 0.5*aPosition;\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n  ",`\n    precision highp float;\n    uniform sampler2D uSampler0;\n    in vec2 vPosition;\n    out vec4 fColor;\n\n    ${o.CAM16}\n\n    void main() {\n      vec3 sRGB = sRGB_EOTF(texture(uSampler0, vPosition).rgb);\n      vec3 Jab = sRGB_to_CAM16_UCS(sRGB);\n      fColor = vec4(Jab, 1.0);\n    }\n  `),n.update=f(x,`\n    uniform sampler2D uSampler0;\n    layout(location=1) in int aPosition;\n    out vec3 vColor;\n\n    ${o.kMeans}\n\n    void main() {\n      ivec2 ts = textureSize(uSampler0, 0);\n      ivec2 xy = ivec2(aPosition%ts.x, aPosition/ts.x);\n      vec2 uv = (0.5 + vec2(xy))/vec2(ts);\n      vec3 Jab = texture(uSampler0, uv).xyz;\n      float x = (0.5 + float(closest(Jab)))/float(K);\n      gl_Position = vec4(2.0*x - 1.0, 0.0, 0.0, 1.0);\n      gl_PointSize = 1.0;\n      vColor = Jab;\n    }\n  `,"\n    precision highp float;\n    in vec3 vColor;\n    out vec4 fColor;\n\n    void main() {\n      fColor = vec4(vColor, 1.0);\n    }\n  "),n.reseed=f(x,"\n    layout(location=0) in vec2 aPosition;\n    out vec2 vPosition;\n\n    void main() {\n      vPosition = 0.5 + 0.5*aPosition;\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n  ","\n    precision highp float;\n    uniform sampler2D uSampler0;\n    uniform sampler2D uSampler1;\n    uniform float uTime;\n    in vec2 vPosition;\n    out vec4 fColor;\n\n    vec2 hash22(vec2 p) {\n      vec3 p3 = fract(vec3(p.xyx)*vec3(.1031, .1030, .0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xx + p3.yz)*p3.zy);\n    }\n\n    void main() {\n      vec2 h = hash22(1e3*vec2(fract(uTime), vPosition.x));\n      vec4 curr = texture(uSampler1, vPosition);\n      vec4 next = texture(uSampler0, h.xy);\n      fColor = curr.w > 0.0 ? curr : next;\n    }\n  "),n.render=f(x,"\n    layout(location=0) in vec2 aPosition;\n    out vec2 vPosition;\n\n    void main() {\n      vPosition = 0.5 + 0.5*aPosition;\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n  ",`\n    precision highp float;\n    uniform sampler2D uSampler0;\n    uniform sampler2D uSampler1;\n    uniform sampler2D uSampler2;\n    uniform float uTime;\n    in vec2 vPosition;\n    out vec4 fColor;\n\n    ${o.kMeans}\n    ${o.CAM16}\n\n    void main() {\n      const vec3 ones = vec3(-1.0, 0.0, 1.0);\n      const vec2 sp = vec2(16.0, 8.0);\n      vec2 s0 = vec2(textureSize(uSampler0, 0));\n      vec2 s2 = vec2(textureSize(uSampler2, 0));\n      vec2 uv = (s0*(ones.zy + ones.xz*vPosition) - 12.0)/4.0/sp;\n      if (0.0 <= min(uv.x, uv.y) && max(uv.x, uv.y) <= 1.0) {\n        vec4 Jab = texture(uSampler1, vec2((floor(sp.y*uv.y) + uv.x)/sp.y, 0.5));\n        vec3 sRGB = CAM16_UCS_to_sRGB(Jab.xyz/Jab.w);\n        fColor = vec4(sRGB_OETF(sRGB), 1.0);\n      }\n      else {\n        vec4 noise = texture(uSampler2, s0/s2*vPosition);\n        vec3 dither = 0.04*(noise.xyz - 0.5);\n        vec3 Jab = texture(uSampler0, vPosition).xyz + dither;\n        vec3 Jab_p = uMeans[closest(Jab)];\n        vec3 sRGB_p = CAM16_UCS_to_sRGB(Jab_p);\n        fColor = vec4(sRGB_OETF(sRGB_p), 1.0);\n      }\n    }\n  `),n.points=f(x,`\n    uniform float uTime;\n    uniform sampler2D uSampler0;\n    layout(location=1) in int aPosition;\n    out vec3 vColor;\n\n    ${o.kMeans}\n    ${o.CAM16}\n\n    #define perspective(fov, r, n, f) mat4(      1.0/r/tan(0.5*fov), 0.0, 0.0, 0.0,      0.0, 1.0/tan(0.5*fov), 0.0, 0.0,      0.0, 0.0, -(f + n)/(f - n), -1.0,      0.0, 0.0, -(2.0*f*n)/(f - n), 0.0    )\n\n    vec4 hash43(vec3 p) {\n      vec4 p4 = fract(vec4(p.xyzx)*vec4(.1031, .1030, .0973, .1099));\n      p4 += dot(p4, p4.wzxy + 33.33);\n      return fract((p4.xxyz + p4.yzzw)*p4.zywx);\n    }\n\n    mat2 rot(float a) {\n      float c = cos(a);\n      float s = sin(a);\n      return mat2(c, s, -s, c);\n    }\n\n    vec3 sphere(vec2 uv) {\n      float theta = radians(360.0)*uv.x;\n      float phi = acos(1.0 - 2.0*uv.y);\n      float x = sin(phi)*cos(theta);\n      float y = sin(phi)*sin(theta);\n      float z = cos(phi);\n      return vec3(x, y, z);\n    }\n\n    void main() {\n      ivec2 ts = textureSize(uSampler0, 0);\n      ivec2 xy = ivec2(aPosition%ts.x, aPosition/ts.x);\n      vec2 uv = (0.5 + vec2(xy))/vec2(ts);\n      vec3 Jab = texture(uSampler0, uv).xyz;\n      vec3 Jab_p = uMeans[closest(Jab)];\n      vec3 sRGB_p = CAM16_UCS_to_sRGB(Jab_p);\n      vec4 h = hash43(1e3*vec3(fract(uTime), uv));\n      float c = step(0.95, h.w);\n      vec4 p = vec4(mix(Jab.yxz, Jab_p.yxz, c), 1.0);\n      p.y -= 0.5;\n      p.xz *= rot(radians(30.0)*uTime);\n      // p.xyz += (1e-3 + 1.0/(1e3*h.z + h.w))*sphere(h.xy);\n      p.xyz += 3e-3*h.z*sphere(h.xy);\n      p.z -= 2.0;\n      p = perspective(radians(35.0), 1.0, 1e-3, 1e1)*p;\n      float s = 1.0/p.w;\n      float cs = ceil(s);\n      vColor = mix(1.0, 20.0, c)*(s*s)/(cs*cs)*sRGB_p;\n      gl_Position = p;\n      gl_PointSize = cs;\n    }\n  `,"\n    precision highp float;\n    in vec3 vColor;\n    out vec4 fColor;\n\n    void main() {\n      fColor = vec4(vColor, 1.0);\n    }\n  "),n.blur=f(x,"\n    layout(location=0) in vec2 aPosition;\n    out vec2 vPosition;\n\n    void main() {\n      vPosition = 0.5 + 0.5*aPosition;\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n  ","\n    precision highp float;\n    uniform sampler2D uSampler0;\n    uniform vec2 uDirection;\n    uniform float uRadius;\n    in vec2 vPosition;\n    out vec4 fColor;\n\n    float gauss(float sigma, float x) {\n      float k = 2.0*pow(sigma, 2.0);\n      return exp(-x*x/k)/sqrt(radians(180.0)*k);\n    }\n\n    void main() {\n      vec2 px = 1.0/vec2(textureSize(uSampler0, 0));\n      vec3 acc = vec3(0.0);\n      for (float x = -uRadius; x <= uRadius; x += 1.0) {\n        vec4 t = texture(uSampler0, vPosition + px*x*uDirection);\n        acc += gauss(0.3*uRadius, x)*t.rgb;\n      }\n      fColor = vec4(acc/3.0, 1.0);\n    }\n  "),n.final=f(x,"\n    layout(location=0) in vec2 aPosition;\n    out vec2 vPosition;\n\n    void main() {\n      vPosition = 0.5 + 0.5*aPosition;\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n  ",`\n    precision highp float;\n    uniform sampler2D uSampler0;\n    uniform sampler2D uSampler1;\n    uniform sampler2D uSampler2;\n    uniform float uTime;\n    in vec2 vPosition;\n    out vec4 fColor;\n\n    ${o.CAM16}\n    ${o.ACES}\n\n    void main() {\n      const vec3 ones = vec3(-1.0, 0.0, 1.0);\n      const vec2 sp = vec2(5.0, 5.0);\n      vec2 s0 = vec2(textureSize(uSampler0, 0));\n      vec2 uv = (s0*(ones.zy + ones.xz*vPosition) - 24.0)/12.0/sp;\n      if (0.0 <= min(uv.x, uv.y) && max(uv.x, uv.y) <= 1.0) {\n        vec4 Jab = texture(uSampler2, vec2((floor(sp.y*uv.y) + uv.x)/sp.y, 0.5));\n        vec3 sRGB = CAM16_UCS_to_sRGB(Jab.xyz/Jab.w);\n        fColor = vec4(sRGB_OETF(sRGB), 1.0);\n      }\n      else {\n        vec3 c0 = texture(uSampler0, vPosition).rgb;\n        vec3 c1 = texture(uSampler1, vPosition).rgb;\n        fColor = vec4(sRGB_OETF(ACES(c0 + c1/2.0)), 1.0);\n      }\n    }\n  `)})(e||(e={})),function(n){const o=n=>o=>{o.texParameteri(3553,10240,n),o.texParameteri(3553,10241,n)},e=o(9728),t=o(9729);n.source=p(x)(t,(n=>n.pixelStorei(37440,!0))),n.bluenoise=p(x)(e),n.array=Array.from([,,,,,,],(()=>{return p(x)(e,(n=560,o=560,e=>{e.texImage2D(3553,0,34836,n,o,0,6408,5126,null)}));var n,o})),x.bindTexture(3553,n.array[1]),x.texImage2D(3553,0,34836,25,1,0,6408,5126,null),x.bindTexture(3553,n.array[2]),x.texImage2D(3553,0,34836,25,1,0,6408,5126,null),c(new Image,{src:"bluenoise.png",onload(){x.bindTexture(3553,n.bluenoise),x.texImage2D(3553,0,6408,6408,5121,this)}})}(t||(t={})),(n=>{n.array=t.array.map((n=>((n,o=36160)=>{const e=n.createFramebuffer();return r(n,e,(e=>n.bindFramebuffer(o,e)))})(x)((o=>{o.framebufferTexture2D(36160,36064,3553,n,0)}))))})(a||(a={})),(n=>{n.points=n=>o=>{const e=new Int32Array(Array(2073600).keys());o.bufferData(34962,e,35044),o.vertexAttribIPointer(n,1,5124,0,0),o.enableVertexAttribArray(n)},n.triangle=n=>o=>{const e=Float32Array.of(-1,1,-1,-3,3,1);o.bufferData(34962,e,35044),o.vertexAttribPointer(n,2,5126,!1,0,0),o.enableVertexAttribArray(n)}})(i||(i={})),x.enable(3042),x.blendFunc(1,1),u(x)(i.points(1)),u(x)(i.triangle(0));(async()=>{const o=new Float32Array(100),i=new Float32Array(75);for(;;){const s=await new Promise(requestAnimationFrame),{videoWidth:v,videoHeight:r}=n.video;if(!v)continue;const u=Math.sqrt(5e5/v/r),p=Math.round(u*v),_=Math.round(u*r);x.bindFramebuffer(36160,a.array[0]),x.bindTexture(3553,t.array[0]),x.texImage2D(3553,0,34836,p,_,0,6408,5126,null),x.activeTexture(33984),x.bindTexture(3553,t.source),x.texImage2D(3553,0,6408,6408,5121,n.video),x.useProgram(e.convert),x.viewport(0,0,p,_),x.clear(16384),x.drawArrays(4,0,3);{x.bindFramebuffer(36160,a.array[1]),x.activeTexture(33984),x.bindTexture(3553,t.array[0]);const n=l(x,e.update);x.useProgram(e.update),x.uniform3fv(n("uMeans"),i),x.viewport(0,0,25,1),x.clear(16384),x.drawArrays(0,0,p*_)}{x.bindFramebuffer(36160,a.array[2]),x.activeTexture(33984),x.bindTexture(3553,t.array[0]),x.activeTexture(33985),x.bindTexture(3553,t.array[1]);const n=l(x,e.reseed);x.useProgram(e.reseed),x.uniform1f(n("uTime"),.001*s),x.viewport(0,0,25,1),x.clear(16384),x.drawArrays(4,0,3)}x.readPixels(0,0,25,1,x.RGBA,x.FLOAT,o);for(let n=0,e=0;i.length>n;n+=3,e+=4){const t=o[e+3];i[n+0]=o[e+0]/t,i[n+1]=o[e+1]/t,i[n+2]=o[e+2]/t}{x.bindFramebuffer(36160,a.array[3]),x.activeTexture(33984),x.bindTexture(3553,t.array[0]);const n=l(x,e.points);x.useProgram(e.points),x.uniform1f(n("uTime"),.001*s),x.uniform3fv(n("uMeans"),i),x.viewport(0,0,560,560),x.clear(16384),x.drawArrays(0,0,p*_)}{const n=l(x,e.blur),o=n("uDirection"),i=n("uRadius");x.bindFramebuffer(36160,a.array[5]),x.useProgram(e.blur),x.viewport(0,0,560,560),x.clear(16384),x.activeTexture(33984);for(let n=0;4>n;n++)x.uniform1f(i,3*2**n),x.bindFramebuffer(36160,a.array[4]),x.bindTexture(3553,t.array[3]),x.uniform2f(o,1,0),x.clear(16384),x.drawArrays(4,0,3),x.bindFramebuffer(36160,a.array[5]),x.bindTexture(3553,t.array[4]),x.uniform2f(o,0,1),x.drawArrays(4,0,3)}x.activeTexture(33984),x.bindTexture(3553,t.array[3]),x.activeTexture(33985),x.bindTexture(3553,t.array[5]),x.activeTexture(33986),x.bindTexture(3553,t.array[2]),c(x.canvas,{width:560,height:560}),x.bindFramebuffer(36160,null),x.useProgram(e.final),x.viewport(0,0,560,560),x.clear(16384),x.drawArrays(4,0,3)}})();
</script>
